<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>statFEM_analysis.twoDim &mdash; statFEM_analysis 0.0.1 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> statFEM_analysis
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../README.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Notebooks.html">Reference Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scripts.html">Experiments from paper</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">API Documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">statFEM_analysis</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>statFEM_analysis.twoDim</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for statFEM_analysis.twoDim</h1><div class="highlight"><pre>
<span></span><span class="c1"># AUTOGENERATED! DO NOT EDIT! File to edit: 01_twoDim.ipynb (unless otherwise specified).</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;mean_assembler&#39;</span><span class="p">,</span> <span class="s1">&#39;kernMat&#39;</span><span class="p">,</span> <span class="s1">&#39;BigPhiMat&#39;</span><span class="p">,</span> <span class="s1">&#39;cov_assembler&#39;</span><span class="p">,</span> <span class="s1">&#39;m_post&#39;</span><span class="p">,</span> <span class="s1">&#39;sample_gp&#39;</span><span class="p">,</span> <span class="s1">&#39;gen_sensor&#39;</span><span class="p">,</span>
           <span class="s1">&#39;MyExpression&#39;</span><span class="p">,</span> <span class="s1">&#39;fem_cov_assembler_post&#39;</span><span class="p">,</span> <span class="s1">&#39;m_post_fem_assembler&#39;</span><span class="p">,</span> <span class="s1">&#39;c_post&#39;</span><span class="p">,</span> <span class="s1">&#39;post_fem_cov_assembler&#39;</span><span class="p">,</span>
           <span class="s1">&#39;c_post_fem_assembler&#39;</span><span class="p">]</span>

<span class="c1"># Cell</span>
<span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">integrate</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">cdist</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">sqrtm</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csr_matrix</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">spsolve</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>
<span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>

<span class="c1"># code to assemble the mean for a given mesh size</span>
<div class="viewcode-block" id="mean_assembler"><a class="viewcode-back" href="../../statFEM_analysis.html#statFEM_analysis.twoDim.mean_assembler">[docs]</a><span class="k">def</span> <span class="nf">mean_assembler</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">f_bar</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function assembles the mean for the statFEM prior for our 1-D problem.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    h : float</span>
<span class="sd">        mesh size h</span>
<span class="sd">    f_bar : FEniCS function/expression/constant</span>
<span class="sd">        mean function for the forcing</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    FEniCS function</span>
<span class="sd">        mean of the approximate statFEM prior</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get size of the grid</span>
    <span class="n">J</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">h</span><span class="p">))</span>

    <span class="c1"># set up the mesh and function space for FEM</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">J</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># set up boundary condition</span>
    <span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">on_boundary</span>

    <span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">boundary</span><span class="p">)</span>
    <span class="c1"># set up the functions κ and f</span>
    <span class="n">κ</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">f_bar</span>

    <span class="c1"># set up the bilinear form for the variational problem</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">κ</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span><span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>

    <span class="c1"># set up the linear form</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

    <span class="c1"># solve the variational problem</span>
    <span class="n">μ</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">μ</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">μ</span></div>

<span class="c1"># Cell</span>
<div class="viewcode-block" id="kernMat"><a class="viewcode-back" href="../../statFEM_analysis.html#statFEM_analysis.twoDim.kernMat">[docs]</a><span class="k">def</span> <span class="nf">kernMat</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">grid</span><span class="p">,</span><span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">translation_inv</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to compute the covariance matrix :math:`K` corresponding to the covariance kernel :math:`k` on a grid.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    k : function</span>
<span class="sd">        forcing covariance function</span>
<span class="sd">    grid : array</span>
<span class="sd">        grid on which to evaluate the covariance function</span>
<span class="sd">    parallel : bool, optional</span>
<span class="sd">        specifies whether or not the cov kernel is translation invariant, by default True</span>
<span class="sd">    translation_inv : bool, optional</span>
<span class="sd">        specifies whether or not the cov kernel is translation invariant, by default False</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array</span>
<span class="sd">        Covariance matrix K with :math:`ij-`th entry :math:`K_{ij}=k(x_i,x_j)` where :math:`x_i` is the :math:`i`-th point of the grid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get the length of the grid</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># preallocate an n x n array of zeros to hold the cov matrix</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>

    <span class="c1"># check if the cov matrix should be computed in parallel</span>
    <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
        <span class="c1"># compute the cov matrix in parallel by computing the upper triangular part column by column</span>
        <span class="c1"># set up function to compute the ith column of the upper triangular part:</span>
        <span class="k">def</span> <span class="nf">processInput</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span><span class="n">grid</span><span class="p">[</span><span class="n">j</span><span class="p">,:])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">)])</span>

        <span class="c1"># get the number of cpu cores present and compute the upper triangular columns in parallel</span>
        <span class="n">num_cores</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">num_cores</span><span class="p">)(</span><span class="n">delayed</span><span class="p">(</span><span class="n">processInput</span><span class="p">)(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

        <span class="c1"># store the results in the appropriate positions in K</span>
        <span class="c1">#for (i,v) in enumerate(results[0:n-1]):</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">results</span><span class="p">):</span> <span class="c1"># is this correct???</span>
            <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">:]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="c1"># only the upper triangular part has been formed, so use the symmetry of the cov mat to get full K:</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">K</span> <span class="o">+</span> <span class="n">K</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">K</span>
    <span class="k">elif</span> <span class="n">translation_inv</span><span class="p">:</span>
        <span class="c1"># reshape grid so that it has correct dimensions</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># compute the distance matrix D</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="n">grid</span><span class="p">)</span>

        <span class="c1"># evaluate the kernel function using D</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">k</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">K</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># compute the cov mat using a nested for loop</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
                <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span><span class="n">grid</span><span class="p">[</span><span class="n">j</span><span class="p">,:])</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">K</span> <span class="o">+</span> <span class="n">K</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">K</span></div>

<span class="c1"># Cell</span>
<div class="viewcode-block" id="BigPhiMat"><a class="viewcode-back" href="../../statFEM_analysis.html#statFEM_analysis.twoDim.BigPhiMat">[docs]</a><span class="k">def</span> <span class="nf">BigPhiMat</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">grid</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to compute the :math:`\Phi` matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    J : int</span>
<span class="sd">        controls the FE mesh size (:math:`h=1/J^{2}`)</span>
<span class="sd">    grid : array</span>
<span class="sd">        grid in the definition of :math:`\Phi`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    csr_matrix</span>
<span class="sd">        :math:`\Phi` matrix returned as a sparse csr_matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># create the FE mesh and function space</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitIntervalMesh</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># get the tree for the mesh</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bounding_box_tree</span><span class="p">()</span>
    <span class="c1"># set up a function to compute the ith column of Phi corresponding to the ith grid point</span>
    <span class="c1"># create the FE mesh and function space</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">J</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># get the tree for the mesh</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bounding_box_tree</span><span class="p">()</span>
    <span class="c1"># set up a function to compute the ith column of Phi corresponding to the ith grid point</span>
    <span class="k">def</span> <span class="nf">Φ</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">cell_index</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">compute_first_entity_collision</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">))</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">cell_index</span><span class="p">)</span>
        <span class="n">cell_global_dofs</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">dofmap</span><span class="p">()</span><span class="o">.</span><span class="n">cell_dofs</span><span class="p">(</span><span class="n">cell_index</span><span class="p">)</span>
        <span class="n">vertex_coordinates</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_vertex_coordinates</span><span class="p">()</span>
        <span class="n">cell_orientation</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">orientation</span><span class="p">()</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">element</span><span class="p">()</span><span class="o">.</span><span class="n">evaluate_basis_all</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">vertex_coordinates</span><span class="p">,</span><span class="n">cell_orientation</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">cell_global_dofs</span><span class="p">,</span><span class="n">i</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">cell_global_dofs</span><span class="p">))</span>
    <span class="c1"># compute all the columns of Phi using the function above</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">Φ</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">))]</span>
    <span class="c1"># assemble the sparse matrix Phi using the results</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">))])</span>
    <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">))])</span>
    <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">))])</span>
    <span class="k">return</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="n">data</span><span class="p">,(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)),</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">dim</span><span class="p">(),</span><span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)))</span></div>

<span class="c1"># Cell</span>
<span class="c1"># function to assemble the fem covariance</span>
<div class="viewcode-block" id="cov_assembler"><a class="viewcode-back" href="../../statFEM_analysis.html#statFEM_analysis.twoDim.cov_assembler">[docs]</a><span class="k">def</span> <span class="nf">cov_assembler</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">k_f</span><span class="p">,</span><span class="n">grid</span><span class="p">,</span><span class="n">parallel</span><span class="p">,</span><span class="n">translation_inv</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to assemble the approximate FEM covariance matrix on the reference grid.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    J : int</span>
<span class="sd">        controls the FE mesh size (:math:`h=1/J^{2}`)</span>
<span class="sd">    k_f : function</span>
<span class="sd">        the covariance function for the forcing :math:`f`</span>
<span class="sd">    grid : array</span>
<span class="sd">        the reference grid where the FEM cov matrix should be computed on</span>
<span class="sd">    parallel : bool</span>
<span class="sd">        argument indicating whether the intermediate computation of :math:`C_f` should be done in parallel</span>
<span class="sd">    translation_inv : bool</span>
<span class="sd">        argument indicating whether the intermediate computation of :math:`C_f` should be computed assuming `k_f` is translation invariant or not</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array</span>
<span class="sd">        approximate FEM covariance matrix on the reference grid</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># set up mesh and function space</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">J</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># set up FE grid</span>
    <span class="n">x_grid</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">tabulate_dof_coordinates</span><span class="p">()</span>

    <span class="c1"># set up boundary condition</span>
    <span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">on_boundary</span>

    <span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">boundary</span><span class="p">)</span>

    <span class="c1"># get the boundary and interior dofs</span>
    <span class="n">bc_dofs</span> <span class="o">=</span> <span class="n">bc</span><span class="o">.</span><span class="n">get_boundary_values</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="n">first</span><span class="p">,</span> <span class="n">last</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">dofmap</span><span class="p">()</span><span class="o">.</span><span class="n">ownership_range</span><span class="p">()</span>
    <span class="n">all_dofs</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">)</span>
    <span class="n">interior_dofs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">all_dofs</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">bc_dofs</span><span class="p">))</span>
    <span class="n">bc_dofs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">bc_dofs</span><span class="p">))</span>

    <span class="c1"># set up the function κ</span>
    <span class="n">κ</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>

    <span class="c1"># get the mass and stiffness matrices as sparse csr_matrices</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

    <span class="n">mass_form</span> <span class="o">=</span> <span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">κ</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span><span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>

    <span class="n">M</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">mass_form</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">as_backend_type</span><span class="p">(</span><span class="n">M</span><span class="p">)</span><span class="o">.</span><span class="n">mat</span><span class="p">()</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">as_backend_type</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">mat</span><span class="p">()</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">getValuesCSR</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">shape</span><span class="o">=</span><span class="n">M</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">getValuesCSR</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">shape</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

    <span class="c1"># extract the submatrices corresponding to the interior dofs</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">interior_dofs</span><span class="p">,:][:,</span><span class="n">interior_dofs</span><span class="p">]</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">interior_dofs</span><span class="p">,:][:,</span><span class="n">interior_dofs</span><span class="p">]</span>

    <span class="c1"># get the forcing cov matrix on the interior nodes of the grid</span>
    <span class="n">Σ_int</span> <span class="o">=</span> <span class="n">kernMat</span><span class="p">(</span><span class="n">k_f</span><span class="p">,</span><span class="n">x_grid</span><span class="p">[</span><span class="n">interior_dofs</span><span class="p">],</span><span class="n">parallel</span><span class="p">,</span><span class="n">translation_inv</span><span class="p">)</span>

    <span class="c1"># form the matrix Q in the defintion of the approximate FEM cov mat</span>
    <span class="c1"># Note: overwrite Σ_int for memory efficiency.</span>
<span class="c1">#     Σ_int = M @ Σ_int @ M.T</span>
    <span class="n">Σ_int</span> <span class="o">=</span> <span class="n">Σ_int</span> <span class="o">@</span> <span class="n">M</span><span class="o">.</span><span class="n">T</span>
    <span class="n">Σ_int</span> <span class="o">=</span> <span class="n">M</span> <span class="o">@</span> <span class="n">Σ_int</span>

    <span class="n">Σ_int</span> <span class="o">=</span> <span class="n">spsolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">Σ_int</span><span class="p">)</span>
    <span class="n">Σ_int</span> <span class="o">=</span> <span class="n">spsolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">Σ_int</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># ensure Σ_int is symmetric</span>
    <span class="n">Σ_int</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">Σ_int</span> <span class="o">+</span> <span class="n">Σ_int</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="c1"># get big phi matrix on the grid (extracting only the rows corresponding to the</span>
    <span class="c1"># interior dofs)</span>
    <span class="n">Phi</span> <span class="o">=</span> <span class="n">BigPhiMat</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">grid</span><span class="p">)[</span><span class="n">interior_dofs</span><span class="p">,:]</span>
    <span class="c1">#print(&quot;Computed Phi&quot;)</span>

    <span class="c1"># assemble cov mat on grid using Phi and Σ_int</span>
    <span class="n">Σ</span> <span class="o">=</span> <span class="n">Phi</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">Σ_int</span> <span class="o">@</span> <span class="n">Phi</span>

    <span class="c1"># ensure Σ is symmetric and return</span>
    <span class="n">Σ</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">Σ</span> <span class="o">+</span> <span class="n">Σ</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Σ</span></div>

<span class="c1"># Cell</span>
<div class="viewcode-block" id="m_post"><a class="viewcode-back" href="../../statFEM_analysis.html#statFEM_analysis.twoDim.m_post">[docs]</a><span class="k">def</span> <span class="nf">m_post</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">B</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function evalutes the posterior mean at the point :math:`x`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : float</span>
<span class="sd">        point where the posterior mean will be evaluated</span>
<span class="sd">    m : function</span>
<span class="sd">        function which computes the prior mean at a given point y</span>
<span class="sd">    c : function</span>
<span class="sd">        function which returns the vector (c(x,y)) for y in Y (note: c is the prior covariance function)</span>
<span class="sd">    v : array</span>
<span class="sd">        vector of noisy sensor readings</span>
<span class="sd">    Y : array</span>
<span class="sd">        vector of sensor locations</span>
<span class="sd">    B : array</span>
<span class="sd">        the matrix :math:`\epsilon^{2}I+C_Y` to be inverted in order to obtain the posterior</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        posterior mean at the point :math:`x`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m_vect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">m</span><span class="p">(</span><span class="n">y_i</span><span class="p">)</span> <span class="k">for</span> <span class="n">y_i</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">c_vect</span> <span class="o">=</span> <span class="n">c</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="c1"># compute the update term</span>
    <span class="n">update</span> <span class="o">=</span> <span class="n">c_vect</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">m_vect</span><span class="o">-</span><span class="n">v</span><span class="p">)</span>

    <span class="c1"># return m_post</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">m</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">update</span><span class="p">)</span></div>

<span class="c1"># Cell</span>
<div class="viewcode-block" id="sample_gp"><a class="viewcode-back" href="../../statFEM_analysis.html#statFEM_analysis.twoDim.sample_gp">[docs]</a><span class="k">def</span> <span class="nf">sample_gp</span><span class="p">(</span><span class="n">n_sim</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">grid</span><span class="p">,</span><span class="n">par</span><span class="p">,</span><span class="n">trans</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to sample a GP with mean :math:`m` and cov :math:`k` on a grid.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_sim : int</span>
<span class="sd">        number of trajectories to be sampled</span>
<span class="sd">    m : function</span>
<span class="sd">        mean function for the GP</span>
<span class="sd">    k : function</span>
<span class="sd">        cov function for the GP</span>
<span class="sd">    grid : array</span>
<span class="sd">        grid of points on which to sample the GP</span>
<span class="sd">    par : bool, optional</span>
<span class="sd">        argument indicating whether the computation of the cov matrix should be done in parallel, by default False</span>
<span class="sd">    trans : bool, optional</span>
<span class="sd">        argument indicating whether the computation of the cov matrix should be computed assuming `k` is translation invariant or not, by default True</span>
<span class="sd">    tol : _type_, optional</span>
<span class="sd">        controls the size of the tiny diagonal perturbation added to cov matrix to ensure it is strictly positive definite, by default 1e-9</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array</span>
<span class="sd">        array containing `n_sim` samples from a GP with mean :math:`m` and cov :math:`k` evaluated on the grid `grid`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get length of grid</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

    <span class="c1"># construct mean vector</span>
    <span class="n">μ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">m</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># construct covariance matrix</span>
    <span class="n">Σ</span> <span class="o">=</span> <span class="n">kernMat</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">grid</span><span class="p">,</span><span class="n">parallel</span><span class="o">=</span><span class="n">par</span><span class="p">,</span><span class="n">translation_inv</span><span class="o">=</span><span class="n">trans</span><span class="p">)</span>

    <span class="c1"># construct the cholesky decomposition Σ = GG^T</span>
    <span class="c1"># we add a small diagonal perturbation to Σ to ensure it</span>
    <span class="c1"># strictly positive definite</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">Σ</span> <span class="o">+</span> <span class="n">tol</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>

    <span class="c1"># draw iid standard normal random vectors</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">n_sim</span><span class="p">))</span>

    <span class="c1"># construct samples from GP(m,k)</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">G</span><span class="nd">@Z</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">μ</span><span class="p">,</span><span class="n">n_sim</span><span class="p">)</span>

    <span class="c1"># return the sampled fields</span>
    <span class="k">return</span> <span class="n">Y</span></div>

<span class="c1"># Cell</span>
<div class="viewcode-block" id="gen_sensor"><a class="viewcode-back" href="../../statFEM_analysis.html#statFEM_analysis.twoDim.gen_sensor">[docs]</a><span class="k">def</span> <span class="nf">gen_sensor</span><span class="p">(</span><span class="n">ϵ</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">par</span><span class="p">,</span><span class="n">trans</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">,</span><span class="n">require</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to generate noisy sensor observations of the solution u on a sensor grid Y.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ϵ: float</span>
<span class="sd">        controls the amount of sensor noise</span>
<span class="sd">    m : function</span>
<span class="sd">        mean function for the forcing :math:`f`</span>
<span class="sd">    k : function</span>
<span class="sd">        cov function for the forcing :math:`f`</span>
<span class="sd">    Y : array</span>
<span class="sd">        vector of sensor locations</span>
<span class="sd">    J : int</span>
<span class="sd">        controls the FE mesh size (:math:`h=1/J^{2}`)</span>
<span class="sd">    par : bool, optional</span>
<span class="sd">        argument indicating whether the computation of the forcing cov matrix should be done in parallel, by default False</span>
<span class="sd">    trans : bool, optional</span>
<span class="sd">        argument indicating whether the computation of the forcing cov matrix should be computed assuming `k` is translation invariant or not, by default True</span>
<span class="sd">    tol : _type_, optional</span>
<span class="sd">        controls the size of the tiny diagonal perturbation added to forcing cov matrix to ensure it is strictly positive definite, by default 1e-9</span>
<span class="sd">    require_f : bool, optional</span>
<span class="sd">        argument indicating whether or not to also return the realisation of the forcing :math:`f`, by default False</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple or array</span>
<span class="sd">        If `require_f` is set to True returns a tuple of two arrays containing the generated noisy sensor observations and the realisation of the forcing. If `require_f` is set to False returns just the generated noisy sensor observations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># get number of sensors from the sensor grid Y</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>

    <span class="c1"># create FEM space and grid</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">J</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">tabulate_dof_coordinates</span><span class="p">()</span>

    <span class="c1"># sample a single f on the grid</span>
    <span class="n">f_sim</span> <span class="o">=</span> <span class="n">sample_gp</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">grid</span><span class="p">,</span><span class="n">par</span><span class="o">=</span><span class="n">par</span><span class="p">,</span><span class="n">trans</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>

    <span class="c1"># set up a FEM function for this realisation</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">set_local</span><span class="p">(</span><span class="n">f_sim</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>

    <span class="c1"># use FENICS to find the corresponding solution u</span>
    <span class="c1"># set up boundary condition</span>
    <span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">on_boundary</span>

    <span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">boundary</span><span class="p">)</span>

    <span class="c1"># set up the function κ</span>
    <span class="n">κ</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>

    <span class="c1"># set up the bilinear form for the variational problem</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">κ</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span><span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>

    <span class="c1"># set up the linear form</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

    <span class="c1"># solve the variational problem</span>
    <span class="n">u_sol</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u_sol</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>

    <span class="c1"># get solution on grid Y:</span>
    <span class="n">u_Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">u_sol</span><span class="p">(</span><span class="n">y_i</span><span class="p">)</span> <span class="k">for</span> <span class="n">y_i</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">])</span>

    <span class="c1"># add N(0,ϵ^2) to each evaluation point</span>
    <span class="n">u_S</span> <span class="o">=</span> <span class="n">u_Y</span> <span class="o">+</span> <span class="n">ϵ</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">require</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">u_S</span><span class="p">,</span> <span class="n">f_sim</span><span class="p">,</span> <span class="n">u_sol</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">u_S</span></div>

<span class="c1"># Cell</span>
<div class="viewcode-block" id="MyExpression"><a class="viewcode-back" href="../../statFEM_analysis.html#statFEM_analysis.twoDim.MyExpression">[docs]</a><span class="k">class</span> <span class="nc">MyExpression</span><span class="p">(</span><span class="n">UserExpression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class to allow users to user their own functions to create a FEniCS UserExpression.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="MyExpression.eval"><a class="viewcode-back" href="../../statFEM_analysis.html#statFEM_analysis.twoDim.MyExpression.eval">[docs]</a>    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>
<div class="viewcode-block" id="MyExpression.value_shape"><a class="viewcode-back" href="../../statFEM_analysis.html#statFEM_analysis.twoDim.MyExpression.value_shape">[docs]</a>    <span class="k">def</span> <span class="nf">value_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">()</span></div></div>

<span class="c1"># Cell</span>
<div class="viewcode-block" id="fem_cov_assembler_post"><a class="viewcode-back" href="../../statFEM_analysis.html#statFEM_analysis.twoDim.fem_cov_assembler_post">[docs]</a><span class="k">def</span> <span class="nf">fem_cov_assembler_post</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">k_f</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">parallel</span><span class="p">,</span><span class="n">translation_inv</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to create the matrix :math:`C_{Y,h}` and the vector function :math:`c^{(h)}` required for the statFEM posterior mean.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    J : int</span>
<span class="sd">        controls the FE mesh size (:math:`h=1/J^{2}`)</span>
<span class="sd">    k_f : function</span>
<span class="sd">        the covariance function for the forcing :math:`f`</span>
<span class="sd">    Y : array</span>
<span class="sd">        vector of sensor locations</span>
<span class="sd">    parallel : bool</span>
<span class="sd">        argument indicating whether the computation of the forcing cov mat should be done in parallel</span>
<span class="sd">    translation_inv : bool</span>
<span class="sd">        argument indicating whether the computation of the forcing cov mat should be computed assuming `k_f` is translation invariant or not</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        returns tuple of matrix :math:`C_{Y,h}` and the vector function :math:`c^{(h)}`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># set up mesh and function space</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">J</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">bounding_box_tree</span><span class="p">()</span>

    <span class="c1"># set up grid</span>
    <span class="n">x_grid</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">tabulate_dof_coordinates</span><span class="p">()</span>

    <span class="c1"># set up boundary condition</span>
    <span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">on_boundary</span>

    <span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">boundary</span><span class="p">)</span>

    <span class="c1"># get the boundary and interior dofs</span>
    <span class="n">bc_dofs</span> <span class="o">=</span> <span class="n">bc</span><span class="o">.</span><span class="n">get_boundary_values</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="n">first</span><span class="p">,</span> <span class="n">last</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">dofmap</span><span class="p">()</span><span class="o">.</span><span class="n">ownership_range</span><span class="p">()</span>
    <span class="n">all_dofs</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">)</span>
    <span class="n">interior_dofs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">all_dofs</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">bc_dofs</span><span class="p">))</span>
    <span class="n">bc_dofs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">bc_dofs</span><span class="p">))</span>

    <span class="c1"># set up the function κ</span>
    <span class="n">κ</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>

    <span class="c1"># get the mass and stiffness matrices</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

    <span class="n">mass_form</span> <span class="o">=</span> <span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">κ</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span><span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>

    <span class="n">M</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">mass_form</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">as_backend_type</span><span class="p">(</span><span class="n">M</span><span class="p">)</span><span class="o">.</span><span class="n">mat</span><span class="p">()</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">as_backend_type</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">mat</span><span class="p">()</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">getValuesCSR</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">shape</span><span class="o">=</span><span class="n">M</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">getValuesCSR</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">shape</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

    <span class="c1"># extract the submatrices corresponding to the interior dofs</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">interior_dofs</span><span class="p">,:][:,</span><span class="n">interior_dofs</span><span class="p">]</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">interior_dofs</span><span class="p">,:][:,</span><span class="n">interior_dofs</span><span class="p">]</span>

    <span class="c1"># get the forcing cov matrix on the interior nodes of the grid</span>
    <span class="n">Σ_int</span> <span class="o">=</span> <span class="n">kernMat</span><span class="p">(</span><span class="n">k_f</span><span class="p">,</span><span class="n">x_grid</span><span class="p">[</span><span class="n">interior_dofs</span><span class="p">],</span><span class="n">parallel</span><span class="p">,</span><span class="n">translation_inv</span><span class="p">)</span>

    <span class="c1"># form the matrix Q in the defintion of the approximate FEM cov mat</span>
    <span class="c1"># Note: overwrite Σ_int for memory efficiency</span>
    <span class="n">Σ_int</span> <span class="o">=</span> <span class="n">M</span> <span class="o">@</span> <span class="n">Σ_int</span> <span class="o">@</span> <span class="n">M</span><span class="o">.</span><span class="n">T</span>

    <span class="n">Σ_int</span> <span class="o">=</span> <span class="n">spsolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">Σ_int</span><span class="p">)</span>
    <span class="n">Σ_int</span> <span class="o">=</span> <span class="n">spsolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">Σ_int</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># ensure Σ_int is symmetric</span>
    <span class="n">Σ_int</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">Σ_int</span> <span class="o">+</span> <span class="n">Σ_int</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="c1"># get big phi matrix on the sensor grid (only need the interior dofs)</span>
    <span class="n">Phi</span> <span class="o">=</span> <span class="n">BigPhiMat</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">Y</span><span class="p">)[</span><span class="n">interior_dofs</span><span class="p">,:]</span>

    <span class="c1"># assemble the FEM cov mat on the sensor grid and ensure it is symmetric</span>
    <span class="n">Σ_s</span> <span class="o">=</span> <span class="n">Phi</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">Σ_int</span> <span class="o">@</span> <span class="n">Phi</span>
    <span class="n">Σ_s</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">Σ_s</span> <span class="o">+</span> <span class="n">Σ_s</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="c1"># set up function to yield the vector (c(x,y)) for y in Y</span>
    <span class="k">def</span> <span class="nf">Φ</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">cell_index</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">compute_first_entity_collision</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">))</span>
        <span class="n">cell_global_dofs</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">dofmap</span><span class="p">()</span><span class="o">.</span><span class="n">cell_dofs</span><span class="p">(</span><span class="n">cell_index</span><span class="p">)</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">cell_index</span><span class="p">)</span>
        <span class="n">vertex_coordinates</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_vertex_coordinates</span><span class="p">()</span>
        <span class="n">cell_orientation</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">orientation</span><span class="p">()</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">element</span><span class="p">()</span><span class="o">.</span><span class="n">evaluate_basis_all</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">vertex_coordinates</span><span class="p">,</span><span class="n">cell_orientation</span><span class="p">)</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">cell_global_dofs</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="n">data</span><span class="p">,(</span><span class="n">cell_global_dofs</span><span class="p">,</span><span class="n">col</span><span class="p">)),</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">dim</span><span class="p">(),</span><span class="mi">1</span><span class="p">))[</span><span class="n">interior_dofs</span><span class="p">,:]</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">c_fem</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Φ</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">Σ_int</span> <span class="o">@</span> <span class="n">Phi</span>

    <span class="c1">#return Σ_s and c_fem</span>
    <span class="k">return</span> <span class="n">Σ_s</span><span class="p">,</span> <span class="n">c_fem</span></div>

<span class="c1"># Cell</span>
<div class="viewcode-block" id="m_post_fem_assembler"><a class="viewcode-back" href="../../statFEM_analysis.html#statFEM_analysis.twoDim.m_post_fem_assembler">[docs]</a><span class="k">def</span> <span class="nf">m_post_fem_assembler</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">f_bar</span><span class="p">,</span><span class="n">k_f</span><span class="p">,</span><span class="n">ϵ</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">v_dat</span><span class="p">,</span><span class="n">par</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">trans</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to assemble the statFEM posterior mean function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    J : int</span>
<span class="sd">        controls the FE mesh size (:math:`h=1/J^{2}`)</span>
<span class="sd">    f_bar : function</span>
<span class="sd">        the mean function for the forcing :math:`f`</span>
<span class="sd">    k_f : function</span>
<span class="sd">        the covariance function for the forcing :math:`f`</span>
<span class="sd">    ϵ : float</span>
<span class="sd">        controls the amount of sensor noise</span>
<span class="sd">    Y : array</span>
<span class="sd">        vector of sensor locations</span>
<span class="sd">    v_dat : array</span>
<span class="sd">        vector of noisy sensor observations</span>
<span class="sd">    par : bool, optional</span>
<span class="sd">        argument passed to `fem_cov_assembler_post`&#39;s argument `parallel`, by default False</span>
<span class="sd">    trans : bool, optional</span>
<span class="sd">        argument passed to `fem_cov_assembler_post`&#39;s argument `translation_inv`, by default True</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    function</span>
<span class="sd">        statFEM posterior mean function</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># get number of sensors</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>

    <span class="c1"># set up mesh and function space</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">J</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># set up boundary condition</span>
    <span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">on_boundary</span>

    <span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">boundary</span><span class="p">)</span>

    <span class="c1"># set up the functions κ and f</span>
    <span class="n">κ</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">f_bar</span>

    <span class="c1"># set up the bilinear form for the variational problem</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">κ</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span><span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>

    <span class="c1"># set up linear form</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

    <span class="c1"># solve the variational problem</span>
    <span class="n">μ_fem</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">μ_fem</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>

    <span class="c1"># use fem_cov_assembler_post to obtain cov mat on sensor grid and function to compute vector</span>
    <span class="c1"># (c(x,y)) for y in Y</span>
    <span class="n">C_fem_s</span><span class="p">,</span> <span class="n">c_fem</span> <span class="o">=</span> <span class="n">fem_cov_assembler_post</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">k_f</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">parallel</span><span class="o">=</span><span class="n">par</span><span class="p">,</span><span class="n">translation_inv</span><span class="o">=</span><span class="n">trans</span><span class="p">)</span>

    <span class="c1"># form B_fem_s by adding noise contribution</span>
    <span class="n">C_fem_s</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ϵ</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="c1"># assemble function to compute posterior mean and return</span>
    <span class="k">def</span> <span class="nf">m_post_fem</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">m_post</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">μ_fem</span><span class="p">,</span><span class="n">c_fem</span><span class="p">,</span><span class="n">v_dat</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">C_fem_s</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">m_post_fem</span></div>

<span class="c1"># Cell</span>
<div class="viewcode-block" id="c_post"><a class="viewcode-back" href="../../statFEM_analysis.html#statFEM_analysis.twoDim.c_post">[docs]</a><span class="k">def</span> <span class="nf">c_post</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">B</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function evaluates the posterior covariance at :math:`(x,y)`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : float</span>
<span class="sd">        one of two points to evaluate the covariance at</span>
<span class="sd">    y : float</span>
<span class="sd">        one of two points to evaluate the covariance at</span>
<span class="sd">    c : function</span>
<span class="sd">        function which returns the prior covariance at any given pair :math:`(x,y)`</span>
<span class="sd">    Y : array</span>
<span class="sd">        vector of sensor locations</span>
<span class="sd">    B : array</span>
<span class="sd">        the matrix :math:`\epsilon^{2}I+C_{Y}` to be inverted in order to obtain the posterior</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        posterior covariance evaluated at :math:`(x,y)`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># compute vectors c_x and c_y:</span>
    <span class="n">c_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y_i</span><span class="p">)</span> <span class="k">for</span> <span class="n">y_i</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">])</span>
    <span class="n">c_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span><span class="p">(</span><span class="n">y_i</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">y_i</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">])</span>

    <span class="c1"># compute update term</span>
    <span class="n">update</span> <span class="o">=</span> <span class="n">c_x</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">c_y</span><span class="p">)</span>

    <span class="c1"># return c_post</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">c</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">update</span><span class="p">)</span></div>

<span class="c1"># Cell</span>
<div class="viewcode-block" id="post_fem_cov_assembler"><a class="viewcode-back" href="../../statFEM_analysis.html#statFEM_analysis.twoDim.post_fem_cov_assembler">[docs]</a><span class="k">def</span> <span class="nf">post_fem_cov_assembler</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">k_f</span><span class="p">,</span><span class="n">grid</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">parallel</span><span class="p">,</span><span class="n">translation_inv</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function which assembles the matrices :math:`\Sigma_X,\Sigma_{XY}`, and :math:`\Sigma_Y` required for the statFEM posterior covariance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    J : int</span>
<span class="sd">        controls the FE mesh size (:math:`h=1/J^{2}`)</span>
<span class="sd">    k_f : function</span>
<span class="sd">        the covariance function for the forcing :math:`f`</span>
<span class="sd">    grid : array</span>
<span class="sd">        the fixed reference grid :math:`\{x_{i}\}_{i=1}^{N}` on which to assemble the posterior cov mat</span>
<span class="sd">    Y : array</span>
<span class="sd">        vector of sensor locations</span>
<span class="sd">    parallel : bool</span>
<span class="sd">        argument indicating whether the computation of the forcing cov mat should be done in parallel</span>
<span class="sd">    translation_inv : bool</span>
<span class="sd">        argument indicating whether the computation of the forcing cov mat should be computed assuming `k_f` is translation invariant or not</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        tuple of the matrices :math:`\Sigma_X,\Sigma_{XY}`, and :math:`\Sigma_Y`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># set up mesh and function space</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">J</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="s1">&#39;Lagrange&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># set up grid</span>
    <span class="n">x_grid</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">tabulate_dof_coordinates</span><span class="p">()</span>

    <span class="c1"># set up boundary condition</span>
    <span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">on_boundary</span>

    <span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">boundary</span><span class="p">)</span>

    <span class="c1"># get the boundary and interior dofs</span>
    <span class="n">bc_dofs</span> <span class="o">=</span> <span class="n">bc</span><span class="o">.</span><span class="n">get_boundary_values</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="n">first</span><span class="p">,</span> <span class="n">last</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">dofmap</span><span class="p">()</span><span class="o">.</span><span class="n">ownership_range</span><span class="p">()</span>
    <span class="n">all_dofs</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">)</span>
    <span class="n">interior_dofs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">all_dofs</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">bc_dofs</span><span class="p">))</span>
    <span class="n">bc_dofs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">bc_dofs</span><span class="p">))</span>

    <span class="c1"># set up the function κ</span>
    <span class="n">κ</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>

    <span class="c1"># get the mass and stiffness matrices</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

    <span class="n">mass_form</span> <span class="o">=</span> <span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">κ</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span><span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>

    <span class="n">M</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">mass_form</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">as_backend_type</span><span class="p">(</span><span class="n">M</span><span class="p">)</span><span class="o">.</span><span class="n">mat</span><span class="p">()</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">as_backend_type</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">mat</span><span class="p">()</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">getValuesCSR</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">shape</span><span class="o">=</span><span class="n">M</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">getValuesCSR</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">shape</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

    <span class="c1"># extract the submatrices corresponding to the interior dofs</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">interior_dofs</span><span class="p">,:][:,</span><span class="n">interior_dofs</span><span class="p">]</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">interior_dofs</span><span class="p">,:][:,</span><span class="n">interior_dofs</span><span class="p">]</span>

    <span class="c1"># get the forcing cov matrix on the interior nodes of the grid</span>
    <span class="n">Σ_int</span> <span class="o">=</span> <span class="n">kernMat</span><span class="p">(</span><span class="n">k_f</span><span class="p">,</span><span class="n">x_grid</span><span class="p">[</span><span class="n">interior_dofs</span><span class="p">],</span><span class="n">parallel</span><span class="p">,</span><span class="n">translation_inv</span><span class="p">)</span>

    <span class="c1"># form the matrix Q in the defintion of the approximate FEM cov mat</span>
    <span class="c1"># Note: overwrite Σ_int for memory efficiency</span>
    <span class="n">Σ_int</span> <span class="o">=</span> <span class="n">M</span> <span class="o">@</span> <span class="n">Σ_int</span> <span class="o">@</span> <span class="n">M</span><span class="o">.</span><span class="n">T</span>

    <span class="n">Σ_int</span> <span class="o">=</span> <span class="n">spsolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">Σ_int</span><span class="p">)</span>
    <span class="n">Σ_int</span> <span class="o">=</span> <span class="n">spsolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">Σ_int</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># ensure Σ_int is symmetric</span>
    <span class="n">Σ_int</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">Σ_int</span> <span class="o">+</span> <span class="n">Σ_int</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="c1"># get big phi matrix on the grid (only need the interior nodes)</span>
    <span class="n">Phi_grid</span> <span class="o">=</span> <span class="n">BigPhiMat</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">grid</span><span class="p">)[</span><span class="n">interior_dofs</span><span class="p">,:]</span>

    <span class="c1"># get big phi matrix on the sensor grid (only need the interior nodes)</span>
    <span class="n">Phi_Y</span> <span class="o">=</span> <span class="n">BigPhiMat</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">Y</span><span class="p">)[</span><span class="n">interior_dofs</span><span class="p">,:]</span>

    <span class="c1"># assemble the FEM cov mat on the sensor grid using Σ_int and Phi_Y</span>
    <span class="n">Σ_Y</span> <span class="o">=</span> <span class="n">Phi_Y</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">Σ_int</span> <span class="o">@</span> <span class="n">Phi_Y</span>

    <span class="c1"># assemble the FEM cov mat on the grid using Σ_int and Phi_grid</span>
    <span class="n">Σ_X</span> <span class="o">=</span> <span class="n">Phi_grid</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">Σ_int</span> <span class="o">@</span> <span class="n">Phi_grid</span>

    <span class="c1"># assemble cross term matrix (with ijth entry c(x_i,y_j))</span>
    <span class="n">Σ_XY</span> <span class="o">=</span> <span class="n">Phi_grid</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">Σ_int</span> <span class="o">@</span> <span class="n">Phi_Y</span>

    <span class="c1"># return these sigma matrices</span>
    <span class="k">return</span> <span class="n">Σ_Y</span><span class="p">,</span> <span class="n">Σ_X</span><span class="p">,</span> <span class="n">Σ_XY</span></div>

<span class="c1"># Cell</span>
<div class="viewcode-block" id="c_post_fem_assembler"><a class="viewcode-back" href="../../statFEM_analysis.html#statFEM_analysis.twoDim.c_post_fem_assembler">[docs]</a><span class="k">def</span> <span class="nf">c_post_fem_assembler</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">k_f</span><span class="p">,</span><span class="n">grid</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">ϵ</span><span class="p">,</span><span class="n">par</span><span class="p">,</span><span class="n">trans</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to assemble the statFEM posterior cov mat on a reference grid specified by grid.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    J : int</span>
<span class="sd">        controls the FE mesh size (:math:`h=1/J^{2}`)</span>
<span class="sd">    k_f : function</span>
<span class="sd">        the covariance function for the forcing :math:`f`</span>
<span class="sd">    grid : array</span>
<span class="sd">        the fixed reference grid :math:`\{x_{i}\}_{i=1}^{N}` on which to assemble the posterior cov mat</span>
<span class="sd">    Y : array</span>
<span class="sd">        vector of sensor locations</span>
<span class="sd">    par : bool</span>
<span class="sd">        argument indicating whether the computation of the forcing cov mat should be done in parallel</span>
<span class="sd">    trans : bool</span>
<span class="sd">        argument indicating whether the computation of the forcing cov mat should be computed assuming `k_f` is translation invariant or not</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array</span>
<span class="sd">        statFEM posterior cov matrix evaluated on `grid`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># use post_fem_cov_assembler to get the sigma matrices needed for posterior cov mat</span>
    <span class="n">Σ_Y</span><span class="p">,</span> <span class="n">Σ_X</span><span class="p">,</span> <span class="n">Σ_XY</span> <span class="o">=</span> <span class="n">post_fem_cov_assembler</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">k_f</span><span class="p">,</span><span class="n">grid</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">parallel</span><span class="o">=</span><span class="n">par</span><span class="p">,</span><span class="n">translation_inv</span><span class="o">=</span><span class="n">trans</span><span class="p">)</span>

    <span class="c1"># create the matrix B (store in Σ_Y for memory efficiency)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="c1"># number of sensor points</span>
    <span class="n">Σ_Y</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ϵ</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="c1">#form the posterior cov matrix (store in Σ_X for memory efficiency)</span>
    <span class="n">Σ_X</span> <span class="o">-=</span> <span class="n">Σ_XY</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">Σ_Y</span><span class="p">,</span><span class="n">Σ_XY</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Σ_X</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Yanni Papandreou.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>